"use strict";(self.webpackChunknotebook=self.webpackChunknotebook||[]).push([[6017],{2e3:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var s=i(4848),t=i(8453);const r={aliases:[],tags:[]},a="SOLID",l={id:"engineering/architecture/principles/solid",title:"SOLID",description:"The SOLID) principles is a set of good practices that focus on flexibility and maintainability. They apply especially well on OOP.",source:"@site/docs/engineering/architecture/principles/solid.md",sourceDirName:"engineering/architecture/principles",slug:"/engineering/architecture/principles/solid",permalink:"/notebook/engineering/architecture/principles/solid",draft:!1,unlisted:!1,editUrl:"https://github.com/satche/notebook/tree/main/docs/engineering/architecture/principles/solid.md",tags:[],version:"current",lastUpdatedAt:1721721519e3,frontMatter:{aliases:[],tags:[]},sidebar:"engineeringSidebar",previous:{title:"Separation of concerns",permalink:"/notebook/engineering/architecture/principles/separation-of-concerns"},next:{title:"Twelve-Factor App",permalink:"/notebook/engineering/architecture/principles/twelve-factor-app"}},o={},c=[{value:"In a nutshell",id:"in-a-nutshell",level:2},{value:"Principles",id:"principles",level:2},{value:"Single Responsibility",id:"single-responsibility",level:3},{value:"Open-closed",id:"open-closed",level:3},{value:"Liskov Substitution",id:"liskov-substitution",level:3},{value:"Interface Segregation",id:"interface-segregation",level:3},{value:"Dependency Inversion",id:"dependency-inversion",level:3},{value:"Resources",id:"resources",level:2}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"solid",children:"SOLID"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"https://wikipedia.org/wiki/solid_(object-oriented_design)",children:"SOLID"})," principles is a set of good practices that focus on flexibility and maintainability. They apply especially well on ",(0,s.jsx)(n.a,{href:"/notebook/engineering/architecture/paradigms/object-oriented",children:"OOP"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"in-a-nutshell",children:"In a nutshell"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://wikipedia.org/wiki/single-responsibility_principle",children:"Single responsibility"})," \u2013 Class has one job to do. Each change in requirements can be done by changing just one class."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://wikipedia.org/wiki/open%e2%80%93closed_principle",title:"open\u2013closed principle",children:"Open\u2013closed"})," \u2013 Class is open to be used by others, but closed to be changed by others."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://wikipedia.org/wiki/liskov_substitution_principle",title:"liskov substitution principle",children:"Liskov substitution"})," \u2013 Class can be replaced by any of its children. Children classes inherit parent's behaviour."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://wikipedia.org/wiki/interface_segregation_principle",title:"interface segregation principle",children:"Interface segregation"})," \u2013 When classes promise each other something, they should separate these promises (interfaces) into many small promises, so it's easier to understand."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://wikipedia.org/wiki/dependency_inversion_principle",title:"dependency inversion principle",children:"Dependency inversion"})," \u2013 When classes talk to each other in a very specific way, they both depend on each other to never change. Instead classes should use promises (interfaces, parents), so classes can change as long as they keep the promise."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"principles",children:"Principles"}),"\n",(0,s.jsx)(n.h3,{id:"single-responsibility",children:"Single Responsibility"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"There should never be more than one reason for a class to change."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Don't put methods in class that has nothing to do with the class."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# BAD\nclass User:\n\tinit(name, email)\n\tsendEmail(message): \u2026\n\n# GOOD\nclass User:\n\tinit(name, email)\n\nclass EmailHandler:\n\tsendEmail(user, message): \u2026\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"User"})," class shouldn\u2019t have the responsibility to ",(0,s.jsx)(n.code,{children:"sendEmail"})]}),"\n",(0,s.jsxs)(n.p,{children:["See: ",(0,s.jsx)(n.a,{href:"/notebook/engineering/architecture/principles/separation-of-concerns",children:"Separation of concerns"})]}),"\n",(0,s.jsx)(n.h3,{id:"open-closed",children:"Open-closed"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Software entities should be open for extension, but closed for modification."}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Class should be generic"}),"\n",(0,s.jsx)(n.li,{children:"Don\u2019t directly modify a class: implement extensions via abstraction / polymorphism."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# BAD\nclass AreaCalculator:\n\tinit(shapes)\n\tsum():\n\t\tforeach (shape in shapes):\n\t\t\tif (shape is "square"): \u2026\n\t\t\telif (shape is "circle"): \u2026\n\t\treturn array_sum(areas)\n\n# GOOD\nclass Square:\n\tinit(length)\n\tarea(): \u2026\n\nclass Circle:\n\tinit(radius)\n\tarea(): \u2026\n\nclass AreaCalculator:\n\tinit(shape, area)\n\tsum():\n\t\tforeach(shape in shapes):\n\t\t\tarea[] = shape.area()\n\t\treturn array_sum(areas)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If we were to add a new shape, we would need to modify the ",(0,s.jsx)(n.code,{children:"AreaCalculator"})," each time. Instead of calculating the area for each shape in the calculator, let each shape provide its own area."]}),"\n",(0,s.jsx)(n.h3,{id:"liskov-substitution",children:"Liskov Substitution"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it."}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When inherited class overrides behavior of parent's method, there is probably an LSP violation."}),"\n",(0,s.jsx)(n.li,{children:"When this happen, create a more generic parent class or interface"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#\xa0BAD\nclass Rectangle:\n\tinit(width, height)\n\tsetWidth(w): width = w\n\tsetHeight(h): height = h\n\tarea() = width * height\n\nclass Square < Rectangle:\n\t# override\n\tsetWidth(w): width = w, height = w\n\tsetHeight(h): width = h, height = h\n\n#\xa0GOOD\ninterface Shape:\n\tarea()\n\nclass Rectangle < Shape:\n\tinit(width, height)\n\tarea(): return width * height\n\nclass Square < Shape:\n\tinit(side)\n\tarea(): return side * 2\n"})}),"\n",(0,s.jsxs)(n.p,{children:["See: ",(0,s.jsx)(n.a,{href:"/notebook/engineering/architecture/paradigms/design-by-contract",children:"Design by contract"})]}),"\n",(0,s.jsx)(n.h3,{id:"interface-segregation",children:"Interface Segregation"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Clients should not be forced to depend upon interfaces that they do not use."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Chose many specific interfaces rather than one general interface"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# BAD\ninterface Animal:\n\trun()\n\tfly()\n\nclass Bird:\n\tmove():\n\t\tanimal.fly\n\n# GOOD\ninterface GroundAnimal:\n\trun()\n\ninterface SkyAnimal:\n\tfly()\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Bird"})," class never use ",(0,s.jsx)(n.code,{children:"run()"}),", so it should be split into other specifics abstract class / interfaces."]}),"\n",(0,s.jsx)(n.h3,{id:"dependency-inversion",children:"Dependency Inversion"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Depend upon abstractions, not concretions."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"High-level modules (e.g. business logic) shouldn't depend on low-level modules (e.g. database operations). Both should depend from abstraction (e.g. interfaces)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# BAD\nclass EventTracker:\n\tinit(logger): logger = ConsoleLogger.new\n\n# GOOD\nclass EventTracker:\n\tinit(logger)\n"})}),"\n",(0,s.jsx)(n.p,{children:"You can specify the logger when you instantiate the class, so you don't depend of a specific logger."}),"\n",(0,s.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:i(5519).A+"",children:"SOLID_cheatsheet"})," \u2013 by ",(0,s.jsx)(n.a,{href:"https://www.monterail.com/",children:"Monterail"})]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},5519:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/files/solid_cheatsheet-c9bf935d16c5d10a70bc7f5efc28712c.pdf"},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var s=i(6540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);